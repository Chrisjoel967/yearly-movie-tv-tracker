<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Yearly Movie & TV Tracker</title>

<style>
  :root{
    --bg:#0b0f17;
    --card:#11182a;
    --card2:#0f1729;
    --border:#23314f;
    --border2:#2b3a5e;
    --text:#e8eefc;
    --muted:#a9b7d6;
  }
  *{ box-sizing:border-box; }
  body{
    margin:0;
    font-family:system-ui, -apple-system, Segoe UI, Roboto, Arial;
    background: radial-gradient(1200px 600px at 20% -10%, #1a2340, var(--bg));
    color:var(--text);
  }
  .wrap{ max-width:1100px; margin:0 auto; padding:20px; }
  h1{ margin:0 0 14px; font-size:42px; letter-spacing:.2px; }

  .card{
    background:linear-gradient(180deg, #131c31, var(--card));
    border:1px solid var(--border);
    border-radius:18px;
    padding:16px;
  }
  .stack{ display:grid; gap:14px; }

  .row{ display:flex; gap:12px; align-items:center; flex-wrap:wrap; }
  input, select, button{
    background:#0e1526;
    border:1px solid var(--border2);
    color:var(--text);
    border-radius:12px;
    padding:11px 12px;
    font-size:16px;
  }
  button{ cursor:pointer; }
  button:hover{ filter:brightness(1.08); }
  button:disabled{ opacity:.55; cursor:not-allowed; }
  .muted{ color:var(--muted); font-size:13px; }
  .pill{
    display:inline-flex;
    gap:8px;
    align-items:center;
    border:1px solid var(--border2);
    background:#0e1526;
    border-radius:999px;
    padding:8px 12px;
    font-size:14px;
    white-space:nowrap;
  }

  /* Search */
  .searchWrap{ position:relative; flex:1; min-width:240px; }
  .searchWrap input{ width:100%; padding-right:46px; }
  .clearX{
    position:absolute;
    right:10px; top:50%;
    transform:translateY(-50%);
    border:none;
    background:transparent;
    padding:6px 8px;
    font-size:22px;
    color:var(--muted);
  }

  /* Results / Items */
  .results,.list{ display:grid; gap:12px; margin-top:12px; }
  .item{
    display:grid;
    grid-template-columns: 64px 1fr auto;
    gap:12px;
    align-items:center;
    background:linear-gradient(180deg, #121a2f, var(--card2));
    border:1px solid var(--border);
    border-radius:16px;
    padding:12px;
  }
  .poster{
    width:64px; height:96px;
    border-radius:12px;
    background:#1b2640;
    object-fit:cover;
  }
  .title{ font-weight:800; font-size:22px; line-height:1.1; }
  .meta{ color:var(--muted); font-size:13px; margin-top:3px; }
  .actions{ display:flex; gap:10px; flex-wrap:wrap; justify-content:flex-end; }
  .btnSmall{ padding:10px 12px; font-size:14px; border-radius:12px; }
  .danger{ border-color:#7a2b2b; }

  /* Layout */
  .gridMain{ display:grid; grid-template-columns: 1fr 1fr; gap:14px; }
  @media (max-width: 920px){
    h1{ font-size:34px; }
    .gridMain{ grid-template-columns: 1fr; }
  }
  @media (max-width: 520px){
    .wrap{ padding:14px; }
    input,select,button{ font-size:15px; }
    .item{ grid-template-columns: 56px 1fr; }
    .item .actions{ grid-column: 1 / -1; justify-content:flex-start; }
    .poster{ width:56px; height:84px; }
    .title{ font-size:20px; }
    .btnSmall{ width:100%; }
    .row > * { width:100%; }
    .row select, .row button{ width:100%; }
  }

  /* Tabs */
  .tabs{ display:flex; gap:10px; flex-wrap:wrap; margin-top:12px; }
  .tab{
    border:1px solid var(--border2);
    background:#0e1526;
    border-radius:999px;
    padding:9px 12px;
    font-size:14px;
    cursor:pointer;
    user-select:none;
  }
  .tab.active{
    background:#152042;
    border-color:#3a55a1;
  }

  /* Stats row */
  .statsRow{ display:flex; gap:10px; flex-wrap:wrap; justify-content:space-between; }
  .statsRow .pill{ flex:1; justify-content:center; }

  /* Modal */
  .backdrop{
    position:fixed; inset:0;
    background:rgba(0,0,0,.55);
    display:none;
    align-items:center;
    justify-content:center;
    padding:18px;
    z-index:999;
  }
  .modal{
    width:min(720px, 100%);
    background:linear-gradient(180deg, #131c31, #0f1729);
    border:1px solid var(--border);
    border-radius:18px;
    padding:16px;
  }
  .modalHeader{ display:flex; justify-content:space-between; gap:12px; align-items:flex-start; }
  .modalTitle{ font-size:22px; font-weight:800; }
  .closeBtn{ border:none; background:transparent; color:var(--muted); font-size:26px; padding:0 6px; cursor:pointer; }
  .seasonGrid{ display:grid; gap:10px; margin-top:12px; }
  .seasonRow{
    display:grid;
    grid-template-columns: 1fr 140px;
    gap:10px;
    align-items:center;
    border:1px solid var(--border);
    background:#0e1526;
    border-radius:14px;
    padding:10px;
  }
  .seasonRow input{ width:100%; }
  .modalFooter{ display:flex; gap:10px; justify-content:flex-end; flex-wrap:wrap; margin-top:14px; }
  @media (max-width:520px){
    .seasonRow{ grid-template-columns: 1fr; }
    .modalFooter button{ width:100%; }
  }
</style>
</head>

<body>
<div class="wrap">
  <h1>Yearly Movie & TV Tracker</h1>

  <!-- SEARCH -->
  <div class="card">
    <div class="row">
      <div class="searchWrap">
        <input id="searchInput" placeholder="Search a movie or TV show…" />
        <button class="clearX" id="clearSearch" aria-label="Clear search">✕</button>
      </div>

      <select id="typeFilter">
        <option value="multi">Movies + TV</option>
        <option value="movie">Movies only</option>
        <option value="tv">TV only</option>
      </select>

      <button id="searchBtn">Search</button>
    </div>

    <div class="muted" style="margin-top:8px;">
      Search TMDB → add to <b>Watchlist</b> or <b>Watched</b>. TV “Watched” opens a seasons/episodes picker.
    </div>

    <div id="results" class="results"></div>
  </div>

  <!-- TIME TOTALS -->
  <div class="card">
    <div class="statsRow">
      <div class="pill"><b>Movies</b> <span id="timeMovies">0h 0m</span></div>
      <div class="pill"><b>TV</b> <span id="timeTV">0h 0m</span></div>
      <div class="pill"><b>Total</b> <span id="timeTotal">0h 0m</span></div>
    </div>
    <div class="muted" style="margin-top:10px;">
      Movies = runtime · TV = total watched episodes × avg episode runtime
    </div>
  </div>

  <div class="gridMain">
    <!-- WATCHLIST -->
    <div class="card">
      <div class="row" style="justify-content:space-between;">
        <div class="title" style="font-size:24px;">Watchlist</div>
      </div>

      <div class="tabs" id="watchlistTabs">
        <div class="tab active" data-tab="movie">Movies</div>
        <div class="tab" data-tab="tv">TV Shows</div>
      </div>

      <div id="watchlistList" class="list"></div>
    </div>

    <!-- WATCHED -->
    <div class="card">
      <div class="row" style="justify-content:space-between;">
        <div class="title" style="font-size:24px;">Watched</div>
      </div>

      <div class="tabs" id="watchedTabs">
        <div class="tab active" data-tab="movie">Movies</div>
        <div class="tab" data-tab="tv">TV Shows</div>
      </div>

      <div id="watchedList" class="list"></div>
    </div>
  </div>
</div>

<!-- MODAL: TV EPISODE PICKER -->
<div class="backdrop" id="tvModalBackdrop">
  <div class="modal" role="dialog" aria-modal="true">
    <div class="modalHeader">
      <div>
        <div class="modalTitle" id="tvModalTitle">TV Episodes</div>
        <div class="muted" id="tvModalSub">Pick how many episodes you watched per season.</div>
      </div>
      <button class="closeBtn" id="tvModalClose" aria-label="Close">✕</button>
    </div>

    <div class="seasonGrid" id="seasonGrid"></div>

    <div class="modalFooter">
      <button class="btnSmall danger" id="tvModalCancel">Cancel</button>
      <button class="btnSmall" id="tvModalSave">Save</button>
    </div>
  </div>
</div>

<script>
/* ===================== CONFIG ===================== */
const TMDB_BEARER = "eyJhbGciOiJIUzI1NiJ9.eyJhdWQiOiJlOWY5NGVkYTNjMzFmMmQ2NWFjM2Y1OWNmMTBhN2VlNiIsIm5iZiI6MTc3MDUxMTY4MS4wNDQsInN1YiI6IjY5ODdkZDQxNjM5ZGJlZWQwNjhjOGQzYiIsInNjb3BlcyI6WyJhcGlfcmVhZCJdLCJ2ZXJzaW9uIjoxfQ.JjpO38-YZKSOX_PXz9zEYiW4zUDpTlFkwPf4XNIOB74"; // <-- paste your token here
const TMDB_BASE = "https://api.themoviedb.org/3";
const POSTER_BASE = "https://image.tmdb.org/t/p/w154";

/* ===================== STATE ===================== */
const STORAGE_KEY = "yearly_tracker_v2_tabs_modal";
let state = loadState();

/**
 * state schema:
 * {
 *   watchlist: [{id, media_type:'movie'|'tv', title, year, poster_path}]
 *   watched:   [
 *     movie: {id, media_type:'movie', title, year, poster_path, runtime_minutes}
 *     tv:    {id, media_type:'tv', title, year, poster_path, avg_episode_minutes, seasons_watched: { [seasonNumber]: episodesWatched }, seasons_meta: { [seasonNumber]: episodeCount } }
 *   ]
 * }
 */
function loadState(){
  try{
    const s = JSON.parse(localStorage.getItem(STORAGE_KEY));
    return s || { watchlist: [], watched: [] };
  }catch{
    return { watchlist: [], watched: [] };
  }
}
function saveState(){ localStorage.setItem(STORAGE_KEY, JSON.stringify(state)); }

function uniqKey(item){ return `${item.media_type}:${item.id}`; }
function minutesToHM(total){
  const h = Math.floor(total/60);
  const m = total % 60;
  return `${h}h ${m}m`;
}
function mediaLabel(t){ return t === "movie" ? "Movie" : "TV"; }

/* ===================== API ===================== */
async function tmdbFetch(path){
  const res = await fetch(`${TMDB_BASE}${path}`, {
    headers: { Authorization: `Bearer ${TMDB_BEARER}`, "Content-Type":"application/json;charset=utf-8" }
  });
  if(!res.ok) throw new Error(`TMDB ${res.status}`);
  return res.json();
}

/* ===================== UI ELEMENTS ===================== */
const elSearchInput = document.getElementById("searchInput");
const elResults = document.getElementById("results");
const elTypeFilter = document.getElementById("typeFilter");

const elTimeMovies = document.getElementById("timeMovies");
const elTimeTV = document.getElementById("timeTV");
const elTimeTotal = document.getElementById("timeTotal");

const elWatchlistList = document.getElementById("watchlistList");
const elWatchedList = document.getElementById("watchedList");

let watchlistTab = "movie";
let watchedTab = "movie";

/* ===================== SEARCH UX ===================== */
document.getElementById("searchBtn").addEventListener("click", runSearch);
elSearchInput.addEventListener("keydown", (e)=>{ if(e.key==="Enter") runSearch(); });

document.getElementById("clearSearch").addEventListener("click", ()=>{
  elSearchInput.value = "";
  elResults.innerHTML = "";
  elSearchInput.focus();
});

elSearchInput.addEventListener("input", ()=>{
  if(elSearchInput.value.trim()===""){
    elResults.innerHTML = "";
  }
});

async function runSearch(){
  const q = elSearchInput.value.trim();
  if(!q) return;

  if(TMDB_BEARER.includes("PASTE_YOUR")){
    elResults.innerHTML = `<div class="muted">Paste your TMDB v4 token into TMDB_BEARER first.</div>`;
    return;
  }

  elResults.innerHTML = `<div class="muted">Searching…</div>`;
  try{
    const type = elTypeFilter.value;
    const data = await tmdbFetch(`/search/${type}?query=${encodeURIComponent(q)}&include_adult=false&language=en-US&page=1`);
    const results = (data.results||[])
      .filter(r => (r.media_type ? (r.media_type==="movie" || r.media_type==="tv") : true))
      .slice(0, 10);

    if(results.length === 0){
      elResults.innerHTML = `<div class="muted">No results found.</div>`;
      return;
    }

    elResults.innerHTML = "";
    results.forEach(r=>{
      const media_type = r.media_type || type;
      const title = media_type === "movie" ? r.title : r.name;
      const year = media_type === "movie" ? (r.release_date||"").slice(0,4) : (r.first_air_date||"").slice(0,4);
      const poster = r.poster_path ? `${POSTER_BASE}${r.poster_path}` : "";

      const exists = isInAnyList(media_type, r.id);

      const div = document.createElement("div");
      div.className = "item";
      div.innerHTML = `
        ${poster ? `<img class="poster" src="${poster}" alt="">` : `<div class="poster"></div>`}
        <div>
          <div class="title">${title}</div>
          <div class="meta">${mediaLabel(media_type)} • ${year || "—"} • Rating: ${Number.isFinite(r.vote_average) ? r.vote_average.toFixed(1) : "—"}</div>
        </div>
        <div class="actions">
          <button class="btnSmall" data-act="watchlist" ${exists ? "disabled":""}>+ Watchlist</button>
          <button class="btnSmall" data-act="watched" ${exists ? "disabled":""}>✓ Watched</button>
        </div>
      `;

      div.querySelector('[data-act="watchlist"]').addEventListener("click", ()=>{
        if(exists) return;
        addToWatchlist({ id:r.id, media_type, title, year, poster_path:r.poster_path });
        renderAll();
      });

      div.querySelector('[data-act="watched"]').addEventListener("click", async ()=>{
        if(exists) return;
        await addToWatchedFlow({ id:r.id, media_type, title, year, poster_path:r.poster_path });
        renderAll();
      });

      elResults.appendChild(div);
    });

  }catch(err){
    elResults.innerHTML = `<div class="muted">Error: ${String(err.message||err)}</div>`;
  }
}

function isInAnyList(media_type, id){
  const k = `${media_type}:${id}`;
  return state.watchlist.some(x=>uniqKey(x)===k) || state.watched.some(x=>uniqKey(x)===k);
}

/* ===================== ADD / MOVE ===================== */
function addToWatchlist(item){
  const k = uniqKey(item);
  if(state.watchlist.some(x=>uniqKey(x)===k) || state.watched.some(x=>uniqKey(x)===k)) return;
  state.watchlist.unshift(item);
  saveState();
}

async function addToWatchedFlow(item){
  // remove from watchlist if present
  const k = uniqKey(item);
  state.watchlist = state.watchlist.filter(x => uniqKey(x) !== k);

  if(item.media_type === "movie"){
    const details = await tmdbFetch(`/movie/${item.id}?language=en-US`);
    state.watched.unshift({
      ...item,
      runtime_minutes: details.runtime || 0
    });
    saveState();
    return;
  }

  // TV: open modal to pick seasons/episodes (default season 1 = 1 episode)
  const details = await tmdbFetch(`/tv/${item.id}?language=en-US`);

  const avgEp = Array.isArray(details.episode_run_time) && details.episode_run_time.length
    ? Math.round(details.episode_run_time.reduce((a,b)=>a+b,0) / details.episode_run_time.length)
    : 45;

  // seasons meta from details.seasons (has episode_count)
  const seasons_meta = {};
  (details.seasons || [])
    .filter(s => typeof s.season_number === "number" && s.season_number > 0) // ignore season 0 specials for now
    .forEach(s => { seasons_meta[s.season_number] = s.episode_count || 0; });

  const baseTV = {
    ...item,
    avg_episode_minutes: avgEp,
    seasons_meta,
    seasons_watched: {}
  };

  // default: season 1, 1 ep (if exists)
  if(seasons_meta[1] > 0) baseTV.seasons_watched[1] = 1;

  // show modal to confirm/edit before saving
  const finalTV = await openTVModal(baseTV);
  if(finalTV){
    state.watched.unshift(finalTV);
    saveState();
  } else {
    // user canceled: put it back into watchlist
    state.watchlist.unshift({ id:item.id, media_type:item.media_type, title:item.title, year:item.year, poster_path:item.poster_path });
    saveState();
  }
}

/* ===================== TABS ===================== */
document.getElementById("watchlistTabs").addEventListener("click", (e)=>{
  const tab = e.target.closest(".tab");
  if(!tab) return;
  watchlistTab = tab.dataset.tab;
  setActiveTab("watchlistTabs", watchlistTab);
  renderWatchlist();
});
document.getElementById("watchedTabs").addEventListener("click", (e)=>{
  const tab = e.target.closest(".tab");
  if(!tab) return;
  watchedTab = tab.dataset.tab;
  setActiveTab("watchedTabs", watchedTab);
  renderWatched();
});
function setActiveTab(containerId, active){
  const c = document.getElementById(containerId);
  c.querySelectorAll(".tab").forEach(t=>{
    t.classList.toggle("active", t.dataset.tab === active);
  });
}

/* ===================== RENDER ===================== */
function posterOrBlank(p){
  return p ? `<img class="poster" src="${POSTER_BASE}${p}" alt="">` : `<div class="poster"></div>`;
}

function renderAll(){
  renderTotals();
  renderWatchlist();
  renderWatched();
}

function renderWatchlist(){
  const list = state.watchlist.filter(i => i.media_type === watchlistTab);
  if(list.length === 0){
    elWatchlistList.innerHTML = `<div class="muted">No ${watchlistTab === "movie" ? "movies" : "TV shows"} in watchlist.</div>`;
    return;
  }
  elWatchlistList.innerHTML = "";
  list.forEach(item=>{
    const div = document.createElement("div");
    div.className = "item";
    div.innerHTML = `
      ${posterOrBlank(item.poster_path)}
      <div>
        <div class="title">${item.title}</div>
        <div class="meta">${mediaLabel(item.media_type)} • ${item.year || "—"}</div>
      </div>
      <div class="actions">
        <button class="btnSmall" data-act="watched">✓ Watched</button>
        <button class="btnSmall danger" data-act="remove">Remove</button>
      </div>
    `;

    div.querySelector('[data-act="watched"]').addEventListener("click", async ()=>{
      await addToWatchedFlow(item);
      renderAll();
    });

    div.querySelector('[data-act="remove"]').addEventListener("click", ()=>{
      state.watchlist = state.watchlist.filter(x => uniqKey(x) !== uniqKey(item));
      saveState();
      renderAll();
    });

    elWatchlistList.appendChild(div);
  });
}

function renderWatched(){
  const list = state.watched.filter(i => i.media_type === watchedTab);
  if(list.length === 0){
    elWatchedList.innerHTML = `<div class="muted">No watched ${watchedTab === "movie" ? "movies" : "TV shows"} yet.</div>`;
    return;
  }
  elWatchedList.innerHTML = "";
  list.forEach(item=>{
    const div = document.createElement("div");
    div.className = "item";

    if(item.media_type === "movie"){
      div.innerHTML = `
        ${posterOrBlank(item.poster_path)}
        <div>
          <div class="title">${item.title}</div>
          <div class="meta">${item.year || "—"} • ${item.runtime_minutes || 0} min</div>
        </div>
        <div class="actions">
          <button class="btnSmall" data-act="toWatchlist">↩ Watchlist</button>
          <button class="btnSmall danger" data-act="remove">Remove</button>
        </div>
      `;
    } else {
      const totalEps = totalWatchedEpisodes(item);
      div.innerHTML = `
        ${posterOrBlank(item.poster_path)}
        <div>
          <div class="title">${item.title}</div>
          <div class="meta">${item.year || "—"} • ${totalEps} ep × ${item.avg_episode_minutes || 0}m</div>
          <div class="muted" style="margin-top:6px;">Tap “Edit” to update seasons/episodes.</div>
        </div>
        <div class="actions">
          <button class="btnSmall" data-act="edit">Edit</button>
          <button class="btnSmall" data-act="toWatchlist">↩ Watchlist</button>
          <button class="btnSmall danger" data-act="remove">Remove</button>
        </div>
      `;

      div.querySelector('[data-act="edit"]').addEventListener("click", async ()=>{
        const updated = await openTVModal(item, true);
        if(updated){
          // replace in watched
          state.watched = state.watched.map(x => uniqKey(x)===uniqKey(item) ? updated : x);
          saveState();
          renderAll();
        }
      });
    }

    div.querySelector('[data-act="toWatchlist"]').addEventListener("click", ()=>{
      // remove from watched, add to watchlist
      state.watched = state.watched.filter(x => uniqKey(x) !== uniqKey(item));
      state.watchlist.unshift({ id:item.id, media_type:item.media_type, title:item.title, year:item.year, poster_path:item.poster_path });
      saveState();
      renderAll();
    });

    div.querySelector('[data-act="remove"]').addEventListener("click", ()=>{
      state.watched = state.watched.filter(x => uniqKey(x) !== uniqKey(item));
      saveState();
      renderAll();
    });

    elWatchedList.appendChild(div);
  });
}

function totalWatchedEpisodes(tvItem){
  const map = tvItem.seasons_watched || {};
  return Object.values(map).reduce((a,b)=>a+(Number(b)||0), 0);
}

function renderTotals(){
  let movieMin = 0;
  let tvMin = 0;

  for(const item of state.watched){
    if(item.media_type === "movie"){
      movieMin += (item.runtime_minutes || 0);
    } else {
      const eps = totalWatchedEpisodes(item);
      tvMin += eps * (item.avg_episode_minutes || 0);
    }
  }

  elTimeMovies.textContent = minutesToHM(movieMin);
  elTimeTV.textContent = minutesToHM(tvMin);
  elTimeTotal.textContent = minutesToHM(movieMin + tvMin);
}

/* ===================== TV MODAL ===================== */
const backdrop = document.getElementById("tvModalBackdrop");
const titleEl = document.getElementById("tvModalTitle");
const subEl = document.getElementById("tvModalSub");
const gridEl = document.getElementById("seasonGrid");
const btnClose = document.getElementById("tvModalClose");
const btnCancel = document.getElementById("tvModalCancel");
const btnSave = document.getElementById("tvModalSave");

function openTVModal(tvItem, isEdit=false){
  return new Promise((resolve)=>{
    // clone (don’t mutate original unless saved)
    const working = JSON.parse(JSON.stringify(tvItem));

    titleEl.textContent = `${working.title} — Episodes Watched`;
    subEl.textContent = "Enter how many episodes you watched per season (0..episode count).";

    // build season rows
    gridEl.innerHTML = "";
    const seasonNumbers = Object.keys(working.seasons_meta || {})
      .map(n=>parseInt(n,10))
      .filter(n=>Number.isFinite(n))
      .sort((a,b)=>a-b);

    if(seasonNumbers.length === 0){
      gridEl.innerHTML = `<div class="muted">No season data found for this show.</div>`;
    }

    seasonNumbers.forEach(sn=>{
      const epCount = working.seasons_meta[sn] || 0;
      const current = (working.seasons_watched && working.seasons_watched[sn]) ? working.seasons_watched[sn] : 0;

      const row = document.createElement("div");
      row.className = "seasonRow";
      row.innerHTML = `
        <div>
          <div style="font-weight:700;">Season ${sn}</div>
          <div class="muted">${epCount} episodes</div>
        </div>
        <div>
          <input type="number" min="0" max="${epCount}" step="1" value="${current}" aria-label="Season ${sn} episodes watched">
        </div>
      `;
      const input = row.querySelector("input");
      input.addEventListener("input", ()=>{
        let v = parseInt(input.value || "0", 10);
        if(!Number.isFinite(v)) v = 0;
        v = Math.max(0, Math.min(epCount, v));
        input.value = v;
        working.seasons_watched[sn] = v;
      });
      gridEl.appendChild(row);
    });

    const close = (val)=>{
      backdrop.style.display = "none";
      document.body.style.overflow = "";
      cleanup();
      resolve(val);
    };

    const onEsc = (e)=>{ if(e.key==="Escape") close(null); };
    const onBackdrop = (e)=>{ if(e.target === backdrop) close(null); };

    function cleanup(){
      window.removeEventListener("keydown", onEsc);
      backdrop.removeEventListener("click", onBackdrop);
      btnClose.onclick = null;
      btnCancel.onclick = null;
      btnSave.onclick = null;
    }

    btnClose.onclick = ()=>close(null);
    btnCancel.onclick = ()=>close(null);
    btnSave.onclick = ()=>{
      // remove zeros to keep storage tidy
      const cleaned = {};
      for(const [sn, v] of Object.entries(working.seasons_watched || {})){
        const n = parseInt(sn,10);
        const val = Number(v)||0;
        if(val > 0) cleaned[n] = val;
      }
      working.seasons_watched = cleaned;

      // if user saved 0 episodes total, keep it but it will show 0
      close(working);
    };

    window.addEventListener("keydown", onEsc);
    backdrop.addEventListener("click", onBackdrop);
    document.body.style.overflow = "hidden";
    backdrop.style.display = "flex";
  });
}

/* ===================== INIT ===================== */
setActiveTab("watchlistTabs", watchlistTab);
setActiveTab("watchedTabs", watchedTab);
renderAll();
</script>
</body>
</html>
